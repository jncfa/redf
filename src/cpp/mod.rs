use crate::redf::{
    DurabilityPolicy, Endpoint, LivelinessPolicy, Qos, QosPreset, QosProfile, Redf,
    ReliabilityPolicy, TopicEndpoint,
};
use crate::Args;
use convert_case::{Case, Casing};
use std::collections::BTreeSet;
use std::io::Write;
use std::path::Path;

fn qos_profile(profile: QosProfile) -> String {
    let reliability = match profile.reliability {
        Some(ReliabilityPolicy::BestEffort) => "rclcpp::ReliabilityPolicy::BestEffort",
        Some(ReliabilityPolicy::Reliable) => "rclcpp::ReliabilityPolicy::Reliable",
        _ => "rclcpp::ReliabilityPolicy::SystemDefault",
    };
    let durability = match profile.durability {
        Some(DurabilityPolicy::TransientLocal) => "rclcpp::DurabilityPolicy::TransientLocal",
        Some(DurabilityPolicy::Volatile) => "rclcpp::DurabilityPolicy::Volatile",
        _ => "rclcpp::DurabilityPolicy::SystemDefault",
    };
    let liveliness = match profile.liveliness {
        Some(LivelinessPolicy::Automatic) => "rclcpp::LivelinessPolicy::Automatic",
        Some(LivelinessPolicy::ManualByTopic) => "rclcpp::LivelinessPolicy::ManualByTopic",
        _ => "rclcpp::LivelinessPolicy::SystemDefault",
    };
    let deadline = match profile.deadline {
        Some(d) => format!("rclcpp::Duration{{{}, {}}}", d.secs, d.nanosecs),
        None => "".to_string(),
    };
    let lifespan = match profile.lifespan {
        Some(d) => format!("rclcpp::Duration{{{}, {}}}", d.secs, d.nanosecs),
        None => "".to_string(),
    };
    let lease_duration = match profile.lease_duration {
        Some(d) => format!("rclcpp::Duration{{{}, {}}}", d.secs, d.nanosecs),
        None => "".to_string(),
    };
    let avoid_ros_namespace_conventions = match profile.avoid_ros_namespace_conventions {
        Some(b) => format!("{b}"),
        None => "".to_string(),
    };

    format!(
        r#"[history_policy, depth]() {{
            rclcpp::QoS qos{{depth}};
            qos.history(history_policy);
            qos.reliability({reliability});
            qos.durability({durability});
            qos.liveliness({liveliness});
            qos.deadline({deadline});
            qos.lifespan({lifespan});
            qos.liveliness_lease_duration({lease_duration});
            qos.avoid_ros_namespace_conventions({avoid_ros_namespace_conventions});
            return qos;
        }}()"#
    )
}

fn qos_preset(preset: QosPreset) -> String {
    match preset {
        QosPreset::Clock => "rclcpp::ClockQoS{}".to_string(),
        QosPreset::ParameterEvents => "rclcpp::ParameterEventsQoS{}".to_string(),
        QosPreset::Parameters => "rclcpp::ParametersQoS{}".to_string(),
        QosPreset::Rosout => "rclcpp::RosoutQoS{}".to_string(),
        QosPreset::SensorData => "rclcpp::SensorDataQoS{}".to_string(),
        QosPreset::Services => "rclcpp::ServicesQoS{}".to_string(),
        QosPreset::SystemDefaults => "rclcpp::SystemDefaultsQoS{}".to_string(),
    }
}

fn topic_endpoint(ep: TopicEndpoint) -> String {
    let description = ep.description;
    let class = ep.title.to_case(Case::Pascal);
    let topic = ep.topic;
    let message_type = ep.message_type.replace("/", "::");
    let qos = match ep.qos {
        Some(Qos::Profile(profile)) => qos_profile(profile),
        Some(Qos::Preset(preset)) => qos_preset(preset),
        _ => format!(
            r#"[history_policy, depth]() {{
            rclcpp::QoS qos{{depth}};
            qos.history(history_policy);
            return qos;
        }}()"#
        ),
    };

    format!(
        r#"/**
 * {description}
 */
class {class} {{
public:
    using MessageType = {message_type};

    static inline std::string topic_name() {{
        static const std::string topic = "{topic}";
        return topic;
    }}

    static inline rclcpp::QoS qos(rclcpp::HistoryPolicy history_policy = rclcpp::HistoryPolicy::SystemDefault, size_t depth = 10) {{
        static const rclcpp::QoS qos = {qos};
        return qos;
    }}
}};
"#
    )
}

pub fn codegen(args: Args, redf: Redf) -> Result<(), Box<dyn std::error::Error>> {
    let project_name = redf.title.to_case(Case::Snake);
    let header_file = format!("{project_name}.hpp");
    let mut f = std::fs::File::create(Path::new(&args.out).join(&header_file))?;

    let messages: BTreeSet<String> = redf
        .endpoints
        .iter()
        .map(|ep| match ep {
            Endpoint::Topic(ep) => ep.message_type.clone(),
        })
        .collect();
    let packages: Vec<String> = messages
        .iter()
        .map(|msg| match msg.split_once("/") {
            Some((prefix, _)) => prefix.to_string(),
            None => msg.clone(),
        })
        .collect();

    writeln!(
        f,
        r#"/* This file is generated by redf */

#pragma once
"#
    )?;

    for msg in &messages {
        writeln!(f, "#include <{}.hpp>", msg.to_case(Case::Snake))?;
    }

    let namespace = match redf.cpp_namespace {
        Some(ns) => ns,
        None => redf.title.to_case(Case::Snake),
    };

    writeln!(
        f,
        r#"#include <rclcpp/qos.hpp>

#include <string>

namespace {namespace} {{
"#
    )?;

    for ep in redf.endpoints {
        let code = match ep {
            Endpoint::Topic(ep) => topic_endpoint(ep),
        };
        writeln!(f, "{code}")?;
    }

    writeln!(f, "}}")?;

    let cmakelists = include_str!("CMakeLists.txt.tmpl").replace("{{project_name}}", &project_name);
    let mut find_packages = String::new();
    for pkg in &packages {
        find_packages += &format!("find_package({})\n", pkg);
    }
    let cmakelists = cmakelists.replace("{{find_packages}}", &find_packages);
    let mut include_dirs = String::new();
    for pkg in &packages {
        include_dirs += &format!("  ${{{}_INCLUDE_DIRS}}\n", pkg);
    }
    let cmakelists = cmakelists.replace("{{include_dirs}}", &include_dirs);
    let mut link_libraries = String::new();
    for pkg in &packages {
        link_libraries += &format!("  ${{{}_LIBRARIES}}\n", pkg);
    }
    let cmakelists = cmakelists.replace("{{link_libraries}}", &link_libraries);
    std::fs::write(Path::new(&args.out).join("CMakeLists.txt"), cmakelists)?;

    let mut maintainers = String::new();
    for maintainer in redf.maintainers {
        maintainers += format!(
            "  <maintainer email=\"{}\">{}</maintainer>\n",
            maintainer.email, maintainer.name
        )
        .as_str();
    }
    let license = format!("  <license>{}</license>", &redf.license);

    let package_xml = include_str!("package.xml.tmpl");
    let package_xml = package_xml.replace("{{version}}", &redf.version);
    let package_xml = package_xml.replace("{{description}}", &redf.description);
    let package_xml = package_xml.replace("{{project_name}}", &project_name);
    let package_xml = package_xml.replace("{{maintainers}}", &maintainers);
    let package_xml = package_xml.replace("{{license}}", &license);
    let mut depends = String::new();
    for pkg in &packages {
        depends += &format!("  <depend>{}</depend>\n", pkg);
    }
    let package_xml = package_xml.replace("{{depends}}", &depends);
    std::fs::write(Path::new(&args.out).join("package.xml"), package_xml)?;

    Ok(())
}
